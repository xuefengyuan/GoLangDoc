[TOC]

# 一、基础篇

### 1、Go中的=和:=有什么区别？

在对一个变量进行赋值前，首先要声明其类型。

```go
// 声明
var age int
// 赋值
age = 18
```

上面两行代码可以使用`:=`来合并成一行代码

```go
age := 18
```

因此它们之间的区别是

- `=` 是赋值
- `:=` 是声明并赋值

一个变量只能声明一次，使用多次`:=`是不允许的，当声明一次后却可以赋值多次，没有限制。

### 2、Go中的指针的意义是什么？

**什么是指针，和指针变量**

普通的变量，存储的是数据，而指针变量，存储的是数据的内存地址。

学习指针，主要有两个运算符。

- `&`：地址运算符，从变量中取得值的内存地址

```go
// 定义普通变量并打印
age := 18
fmt.Pringln(age) // output: 18

prt := &aeg
fmt.Pringln(prt) // output: age的内存地址
```

- `*`：解引用运算符，从内存地址中取得存储的数据

```go
myage := *prt
fmt.Println(myage) // output: 18
```

**指针的意义是什么**

意义一：省内存

> 当你往一个函数传递参数时，若该参数是一个值类型的变量，则在调用函数时，会将原来的变量的值拷贝一遍。
>
> 假想每次传参数都用数组，那么每次数组都要被复制一遍，如果数据大小有100万，在64伴的机器上就需要大约800W字节，即8MB的内存，这样会消耗大量的内存。

意义二：易编码

> 写了一个函数来实现更新某对象里的一些数据，在值类型的变量中，若不使用指针，则函数需要重新返回一个更新过的对象
>
> 使用指针，则可以不用返回对象

### 3、Go多值返回有什么用？

Go语言中函数可以返回多个值，这和其它编程语言有很大的不同。对于有其它编译的编程经验的人来说，最大的障碍不是学习这个特性，而是很难想到去使用这个特性。

利用这个特性，在Go中实现变量的交换，就不需要再使用中间变量(表象上看是这样，但实际上还是会变量的拷贝)了，非常方便

```go
package main

import "fmt"

func swap(a, b int) (int, int) {
    return b, a
}

func main() {
    a := 1
    b := 2
    a, b = swap(a, b)

    fmt.Println(a)
    fmt.Println(b)
}
```

如果返回的值，有不需要的，可以直接使用占位符`_`接收，表示丢弃这个值。

```go
a, _ = swap(a, b)
```

在Go中没有异常机制，当一个函数运行出错的时候，除了返回该功能函数的结果外，还应该返回一个error类型的值。

若该值为nil则表示函数正常运行结束，反之，则函数运行异常。

这是Golang这门语言的设计哲学，因此我们不管在看别人的代码，或者自己写代码都会发现代码中处理都有下面这段代码的身影。

```go
if err != nil {
    // handle error
}
```

### 4、Go有异常类型吗？

在解决这个问题之前，有必要对错误和异常做一个解释。

- **错误**：指的是可能出现问题的地方出现了问题，比如打开一个文件时失败，这种情况下在意料之中的。
- **异常**：指的是不应该出现问题的出现了问题，比如引用了空指针，这种情况在人们的意料之外。

**在Golang里面没有异常类型，只有错误类型 (Error)**

一个函数要想返回错误，通常会使用返回值来表示异常状态，它很像C语言中的错误码，可逐层返回，直到被处理。

```go
f, err := os.Open("test.txt")
if err != nil {
    log.Fatal(err)
}
```

Golang语言中虽然没有异常的概念，但却有更恐怖的panic，由于有了recover，在一定程序上，panic可以类比做异常。

Golang错误和异常 (panic) 是可以相互转换的：

1、**错误转异常**：比如程序逻辑上尝试请求某个URL，最多尝试三次，尝试三次的过程中请求失败是错误，尝试三次后还不成功的话，失败就提升为异常了。

2、**异常转错误**：比如panic触发的异常被recover恢复后，将返回值中的error类型的变量进行赋值，以便上层函数继续走错误处理流程。

### 5、Go中的rune和byte有什么区别？

一个字符串是由若干个字符组合而成的，比如`hello`，就有5个字符组成。

在Golang的字符类型有两种，分别是：

1、byte类型：字节，是unit8的别名类型

2、rune类型：字符，是int32的别名类型

byte和rune，虽然都能表示一个字符，但byte只能表示ACSII码表中的一个字符(ACSII码表总共有256个字符)，数量远不如rune多。

rune表示的是Unicode字符中的任一字符，而Unicode是一个可以表示世界范围内的绝大部分字符的编码，这张表里几乎包含了全世界的所有字符，也包括中文。

能表示的字符更多，意味着它占用的空间，也要更大，所占用空间是4个byte的大小。

以下代码来验证下他们占用空间的差异

``` go
var a byte = 'A'
var b unre = 'B'
fmt.Printf("a 占用 %d 个字节数组\n", unsafe.Sizeof(a)) // 1 个字节
fmt.Printf("b 占用 %d 个字节数组 \n", unsafe.Sizeof(b)) // 4个字节
```

### 6、Go语言中的深拷贝和浅拷贝？

**什么是拷贝？**

当你把a变量的赋值给b变量时，其实就是把a变量拷贝给b变量

```go
a := "hello"
b := a
```

这只是拷贝最简单的一种形式，而有些形式却表现得非常的隐蔽。比如：

- 你往一个函数中传参
- 你向通道中传入对象

这些其实是在Go编译器中都会进行拷贝的动作

**什么是深浅拷贝？**

知道了什么是拷贝，我们再往深点开挖，聊聊深浅拷贝。

咱们先了解下数据结构的两种类型：

- **值类型**：String、Array、Int、Struct、Float、Bool
- **引用类型**：Slice、Map

这两种不同类型在拷贝的时候，在拷贝的时候效果是完全不一样的，这对于很多新手可能是一个坑。

对于值类型来说，你的每一次拷贝，Go都会新申请一块内存空间，来存储它的值，改变其中一个变量并不会影响另外一个变量

```go
func tArry() {

    aArr := [3]int{1, 2, 3}
    fmt.Println(aArr)
    bArr := aArr
    aArr[0] = 5
    fmt.Println("将 aArr 拷贝给 bArr 后，并修改 aArr[0] = 5")
    fmt.Printf("打印 aArr: %v \n", aArr)
    fmt.Printf("打印 bArr: %v \n", bArr)
}
// output
[1 2 3]
将 aArr 拷贝给 bArr 后，并修改 aArr[0] = 88
打印 aArr: [5 2 3] 
打印 bArr: [1 2 3] 
```

从输出结果来看，aArr和bArr相互独立，互不干扰

对于引用类型来说，你的每一次拷贝，Go不会申请新的内存空间，而是使用它的指针，两个变量名其实都指向同一个内存空间，改变其中一个变量，会直接影响另一个变量。

```go
func tSlice() {

    aSlice := []int{1, 2, 3}
    fmt.Println(aSlice)
    bSlice := aSlice
    aSlice[0] = 9
    fmt.Println("将 aSlice 拷贝给 bSlice 后，并修改 aSlice[0] = 9")
    fmt.Printf("打印 aSlice: %v \n", aSlice)
    fmt.Printf("打印 bSlice: %v \n", bSlice)
}

// output
[1 2 3]
将 aSlice 拷贝给 bSlice 后，并修改 aSlice[0] = 9
打印 aSlice: [9 2 3] 
打印 aSlice: [9 2 3] 
```

从上面输出结果看，aSlice的更新直接影响到了bSlice的值

### 7、什么叫字面量和组合字面量？

#### 7.1、什么是字面量？

在Golang的内置基本类型有：

- 布尔类型：bool
- 11个内因的整数数字类型：int8、uin8、int16、uint16、int32、uint32、int64、uint64、int、uint、uintptr
- 浮点数类型：float32、float64
- 复数类型：complex64、complex128
- 字符串类型：string

<font color="red">**这些基本类型的值的文本，就是基本类型字面量。**</font>

如下面这两个字符串，都是字符串字面量，没有用变量名或者常量名来指向这两个字面量，因此也称之为**未命名常量**

```go
"hello, iswbm"

`hello,
iswbm`
```

#### 7.2、同值不同字面量

值的字面量(literal)是代码中值的文字表示，一个值可能存在多种字面量表示。

举个例子，十进制的数值15，可以由三种字面量表示

```go
// 16进制
0xF

// 8进制
017

// 2进制
0b1111
```

通过代码比较，可以看出他们是相等的。

```go
func main() {
    fmt.Println(15 == 0xF)     // true
    fmt.Println(15 == 017)     // true
    fmt.Println(15 == 0b1111)  // true
}
```

#### 7.3、字面量和变量有什么区别？

下面是一段很正常的代码

```go
func foo() string {
    return "hello"
}

func main() {
    bar := foo()
    fmt.Println(&bar)
}
```

换成下面这样

```go
func foo() string {
    return "hello"
}

func main() {
    fmt.Println(&foo())
}
```

在Go 1.7版本中编译器直接报错，如果不是智能的ide编写的代码会在运行过程中报错。

为什么先用变量名接收下再取地址就不会报错，而直接使用在函数返回的值上取地址就不行呢？

这是因为如果不使用一个变量名接收下，函数返回的是一个字符串的文本值，也就是字符串字面量，而这种基本类型的字面量是不可寻地的。

想要使用`&`进行寻址，就必需要用变量名接收下。

#### 7.4、什么是组合字面量？

组合字面量是为结构体、数组、切片、和map构造值，并且每次都会创建新值，它们由字面量的类型后紧跟大括号及元素列表，每个元素面前可以选择性的带一个相关key

**什么意思呢？所谓的组合字面量其实就是把对象的定义和初始化放在一起。**

下面我们来看看结构体、数组、切片和map各自的常规方式和组合字面量方式

**结构体的定义和初始化**

一个struct结构体的常规和定义和初始化是怎么样的

**常规方式**

常规方式这样定义逐一字段赋值，比较繁琐。

```go
type Profile struct {
    Name string
    Age int
    Gender string
}

func main() {
    // 声明对象
    var xm Profile
    
    // 属性赋值
    xm.Name = "iswbm"
    xm.Age = 18
    xm.Gender = "male"
}
```

**组合字面量方式**

```go
type Profile struct {
    Name string
    Age int
    Gender string
}
func main() {
    // 声明+属性赋值
    xm := Profile {
        name: "iswbm",
        Age: 19,
        Gender: "male",
    }
}
```

**数组的定义和初始化**

**常规方式**

下面代码中，我们定义一个指定元素大小的字符串数组，然后一个一个的给元素赋值，即数组变量定义和赋值是分开的。

```go
var planets [4]string

planets[0] = "Mercury"
planets[1] = "Venus"
planets[2] = "Earth"
```

**组合字面量方式**

下面代码是将变量定义和初始化合并了在一起

```go
balls := [4]string {"basketball", "football", "volleyball", "tennis"}
```

**slice的定义和初始化**

**常规方式**

```go
// 第一种
var s []string // 定义切片变量，默认零值nil
s = append(s, "hat", "shirt") // 往s中添加元素，len(s):2,cap(2):2

// 第二种
s := make([]string, 0, 10) // 定义s, s的默认值不为nil

```

**组合字面量方式**

由上面的常规方式或以知道，首先都是要先定义切片，然后再往切片中添加元素。下面看下组合字面方式

```go
s := []string {"hat", "shirt"} // 定义和初始化一步完成，自动计算切片的容量和长度

var s = []string {"hat", "shirt"}
```

**map和定义和初始化**

**常规方式**

```go
// 通过make函数初始化
m := make{map[string]int, 10}
m["english"] = 99
m["math"] = 98
```

**组合字面量方式**

```go
m := map[string]int {
    "english":90,
    "math":80,
}

// 组合字面量初始化多维map
m2 := map[string]map[int]string {
    "english":{
        11:"math",
    },
}
```

使用组合字面量会比常规方式简单不少。

#### 7.5、字面量的寻地问题

字面量，说白了就是未命名的常量，跟常量一样，是不可以寻址的。

以数组字面量为例进行说明

```go
func foo() [3]int {
    return [3]int{1, 2, 3}
}

func main() {
    fmt.Println(&foo())
}

```

### 8、对象选择器自动解引用怎么用？

从一个结构体实例对象中获取属性字段的值，通常都是使用`.`这个操作符，该操作符叫作选择器。

当对象是结构体指针时，你想要获取属性字段时，常规理解是这样做

```go
type Profile struct {
    Name string
}

func main() {
    p1 := &Profile{"iswbm"}
    fmt.Println((*p1).Name)
}
```

更简洁的做法，可以直接省去`*`的取值操作，选择器`.`会直接解引用

```go
type Profile struct {
    Name string
}

func main() {
    p1 := &Profile{"iswbm"}
    fmt.Println(p1.Name)
}
```

```go
type Person struct {
    Name string
}

type (p *Person) Say() {
    fmt.Println((*p).Name)
}

// 可以使用下面这种方式
type (p *Person) Say1() {
    fmt.Println(p.Name)
}
```

### 9、map的值不可寻址，那如何修改值的属性？

什么是不可寻址？

下面代码，有什么问题？

```go
type Person struct {
    Age int
}

func (p *Person) GrowUp() {
    p.Age++
}

func main(){
    m := map[string]Person {
        "iswbm" : Person{Age:20},
    }
    m["iswbm"].Age = 23
    m["iswbm"].GrowUp()
}
```

在goland的ide里面直接报代码异常，错误在下面两行

```go
m["iswbm"].Age = 23
m["iswbm"].GrowUp()
```

我们知道，map的值是不可寻址的，当你使用`m["zhangsan"]`取值时，其实返回的是值的拷贝，虽然与原数据值相同，但是在内存中并不是同一个数据。

当map的值是一个普通对象(非指针)，是无法直接对其修改的。

针对这种问题，解决方法有两种

**第一种：新建变量，修改后再覆盖**

```go
func main(){
    m := map[string]Person {
        "iswbm" : Person{Age:20},
    }
    p := m["iswbm"]
    p.Age = 23
    p.GrowUp()
    m["iswbm"] = p
}
```

**第二种：使用指针的方式**

func main(){
    m := map[string]*Person {
        "iswbm" : &Person{Age:20},
    }
    m["iswbm"].Age = 23
    m["iswbm"].GrowUp()
}

### 10、有类型常量和无类型常量的区别？

在Golang中，常量分为有类型常量和无类型常量

```go
// 有类型常量
const VERSION string = "V1.0.0"
// 无类型常量
const RELEASE = 3
```

他们有什么区别呢？当你把无类型的常量，赋值经一个变量时，无类型常量会被隐式的转化成对应的类型

```go
func main() {
    const RELEASE = 3
    var x int16 = RELEASE
    var y int32 = RELEASE
    
    fmt.Printf("type : %T \n", x) // type : int16
    fmt.Printf("type : %T \n", y) // type : int32
}
```

有类型常量，就不会进行隐式转换，在赋值的时候，类型检查就不会通过，代码直接报错。

```go
func main() {
    const RELEASE int8 = 3
    var x int16 = RELEASE // 代码直接异常
    var y int32 = RELEASE // 代码直接异常
    
    fmt.Printf("type : %T \n", x)
    fmt.Printf("type : %T \n", y) 
}
```

有类型常量在赋值时的解决方法中进行显示类型转换

```go
func main() {
    const RELEASE int8 = 3
    var x int16 = int16(RELEASE)
    var y int32 = int32(RELEASE)
    
    fmt.Printf("type : %T \n", x) // type : int16
    fmt.Printf("type : %T \n", y) // type : int32
}
```

### 11、为什么传参使用切片而不使用数组？

**Golang里面的数组是值类型，切片是引用类型**

**值类型**的对象在做为实参传给函数时，形参是实参的另外一份拷贝数据，对形参的修改不会影响到函数外的实参

```go
func arrayTest(x [2]int) {
    fmt.Printf("%p \n",&x)
}

func main(){
    arrayA := [2]int{3,5}
    fmt.Printf("%p \n",&arrayA)
    arrayTest(arrayA)
}
```

如果每次传参都使用数组，那么每次数组都要补复制一遍，如果数组大小有100万，在64位的机器上就需要花费大约800w字节，这样会消耗大量量的内存。

而**引用类型**，则没有这个拷贝的过程，实参与形参指向的是同一块内存地址

```go
func arrayTest(x []int) {
    fmt.Printf("%p \n",&x)
}

func main(){
    arrayA := make([]int,0)
    fmt.Printf("%p \n",&arrayA)
    arrayTest(arrayA)
}
```

结论：

把一个大数组传递给函数会消耗很多内存，采用切片的方式传参可以避免以上喝弄，切片是引用传递，所以它们不需要使用额外的内存并且比使用数组效率更高。

数组指针也可以避免对值进行拷贝的内存浪费。

### 12、Go语言中的hot path有什么用呢？

hot path，热点路径，就是你程序中那些会频繁执行到的代码。

对于这些代码，由于执行次数非常多，意味着只要有一点设计或编码问题，影响就会不断放大，而相反，你中要在这些代码中做一些优化，带来的效果也非常明显。

hot path只是一个概念，到底你的程序中有哪些hot path还需要根据实际情况分析。

一个比较常见的hot path优化的例子，在`sync.Once`有这么一段代码

在注释中首次提到了 hot path概念

```go
// src/sync/once.go

// Once is an object that will perform exactly one action.
//
// A Once must not be copied after first use.
type Once struct {
    // done indicates whether the action has been performed.
    // It is first in the struct because it is used in the hot path.
    // The hot path is inlined at every call site.
    // Placing done first allows more compact instructions on some architectures (amd64/386),
    // and fewer instructions (to calculate offset) on other architectures.
    done uint32
    m    Mutex
}
```

什么意思呢？

- 当需要访问struct的第一个字段时，我们可以直接对指针解引用来访问第一个字段。
- 要访问其它字段时，除了结构体指针外，还需要提供与第一个字段的偏移量。

在机器码中，这个偏移量是传递指令的附加值，这会使得指令变更更长，对性能的是，CPU必需对结构指针添加偏移量以获取想要访问的字段地址。

因此访问 struct的第一个字段 的机器码更快，更加紧凑。

这里假设字段在内存中的布局与结构定义中的布局相同，因为编译器可以决定改变内存中结构的字段顺序来优化存储空间，目前Go编译器未做这样的优化。

### 13、引用类型与指针，有什么不同？

切片是一个引用类型，将它作为一个参数传入函数后，你在函数里对数据作变更会实时反映到实参切片的。

```go
func foo(s []int) {
    s[0] = 666
}

func main() {
    slice := []int{1, 2}
    fmt.Println(slice) // [1, 2]
    foo(slice)
    fmt.Println(slice) // [666, 2]
}
```

切片这一引用类型，是不是有点像指针的效果？

但它又和指针不一样，这一点主要体现在：在形参中所有的操作并不一定会反映在实参上。

还是以切片为例，在形参上对切片进行扩容，发现形参在扩容后，实参并没有发生改变。

```go
func foo(s []int) {
    s = append(s, 666)
}

func main() {
    slice := []int{1, 2}
    fmt.Println(slice) // [1, 2]
    foo(slice)
    fmt.Println(slice) // [1, 2]
}
```

在函数里你对一个切片append的时候，它会做这些事情：

- 1、新建一个新的切片slice2，其实长度与slice1一样，但容量是slice1的两倍，此时slice底层指向匿名数组和slice1不是同一个。
- 2、将slice1底层的数组元素，一个个的拷贝给slice2底层的数组。
- 3、并把扩容的元素也拷贝到slice2中。
- 4、最后把新的slice2返回回来，这就是为什么指针不用返回，而slice.append也要返回的原因。

从上面流程中可以看到等号左边的s(slice2)和等号右边的s(slice)底层引用的数组已经不是同一个了，因此切片的形参做扩容，并不会影响到实参。

### 14、Go是值传递，还是引用传递、指针传递？

Golang中函数的参数为切片时， 是传引用还是传值？

对于这个问题，很多人认识是传引用，比如下面这段代码

```go
func foo(s []int) {
    s[0] = 666
}

func main() {
    slice := []int{1, 2}
    fmt.Println(slice) // [1, 2]
    foo(slice)
    fmt.Println(slice) // [666, 2]
}
```

如果不了解Golang中切片的底层结构，很可能会误信上面的观点。

其实不是，**Golang中都是值传递，而不是引用传递，也不是指针传递。**

Golang中切片的底层结构是这样的。

```go
type slice struct {
    array unsafe.Pointer
    len int
    cap int
}
```

而当你将切片作为实参传给函数时，函数会拷贝一份实参的结构和数据，生成另一个切片，实参切片和形参切片，不仅是长度，容量相等，连指向底层数组的指针都是一样的。

通过分别打印实参切片和形参切片的指针地址就可以验证

```go
func foo(s []int) {
    fmt.Printf("%p \n", &s) // 0xc00000c080
    s[0] = 666
}

func main() {
    slice := []int{1, 2}
    fmt.Printf("%p \n", &slice) 
    foo(slice)
    fmt.Printf("%p \n", &slice) 
}
```

### 15、Go中哪些是可寻址，哪些是不可寻址的？

**什么叫可寻址？**

可直接使用`&`操作符取地址的对象，就是可寻址的（Addressable）。如下面这个例子

```go
func main() {
    name := "iswbm"
    fmt.Println(&name)
}
```

运行不会报错，name这个变量是可寻址的。

但不能说`"iswbm"`这个字符串是可寻址的。

`"iswbm"` 是字符串，字符串都是不可变的，是不可以寻址的。

结论：

- 指针可以寻址：&Profile{}
- 变量可以寻址：name := Profile{}
- 字面量通通不能寻址：Profile{}

**哪些是可以寻址的？**

变量：&x

```go
func main() {
    name := "iswbm"
    fmt.Println(&name)
}
```

指针： &*x

```go
type Profile struct {
    Name string
}

func main() {
    fmt.Println(unsafe.Pointer(&Profile{Name: "iswbm"}))
}
```

数组元素索引

```go
func main() {
    s := [...]int{2, 4, 6}
    fmt.Println(&s[0])
}
```

切片

```go
func main() {
    fmt.Println([]int{1, 3, 5})
}
```

切片元素索引

```go
func main() {
    s := make([]int, 2, 2)
    fmt.Println(&s[0])
}
```

组合字面量 &struct( X type){value}

所有组合字面量都是不可寻址的。

```go
type Profile struct {
    Name string
}
func new() Profile{
    return Profile{Name: "iswbm"}
}

func main() {
    fmt.Println(&new())
}
```

上面写法与下面写法的区别，下面这个写法代表不同意思，其中的`&`并不是取地址的操作，而是实例化一个结构体指针

```go
type Profile struct {
    Name string
}

func main() {
    fmt.Println(&Profile{Name: "iswbm"})
}
```

虽然字面字面量是不可寻址的，但却可以对组合字面量的字段属性进行寻址(直接访问)

```go
type Profile struct {
    Name string
}

func new() Profile {
    return Profile{Name: "iswbm"}
}

func main() {
    fmt.Println(new().Name)
}
```

**哪些是不可以寻址的**

常量

```go
const VERSION = "v1.0"

func main() {
    fmt.Println(&VERSION)
}
```

字符串

```go
func getStr() string {
    return "iswbm"
}

func main() {
    fmt.Println(&getStr)
}
```

**基本类型字面量**

字面量分：**基本类型字面量** 和 **复合型字面量**

基本类型字面量，是一个值的文本表示，都是不应该也是不可以被寻址的。

```go
func getInt() int {
    return 123
}

func main() {
    fmt.Println(&getInt())
}
```

map中的元素

字典类型比较特殊，从两个角度来推导，假设字典元素可寻址，会出现什么问题？

1、如果字典的元素不存在，则返回零值，而零值是不可变对象，如果能寻址问题就大了。

2、如果字典的元素存在，考虑到Golang中的map实现元素的地址是变化的，这意味着寻址的结果也是无意义的。

基于这两点，map中的元素不可寻址，符合常理

```go
func main() {
    p := map[string]string{
        "name":"iswbm",
    }
    fmt.Println(&p["name"])
}
```

搞懂了这点，应该能理解下面这段代码为什么报错了

```go
type Person struct {
    Name string
    Email string
}

func main() {
    m := map[int]Person{
        1: Person{"Andy", "123@qq.com"},
        2: Person{"Tiny", "456@qq.com"},
        3: Person{"Jack", "789@qq.com"},
    }
    m[1].Name = "Scrapup"
}
```

数组字面量

数组字面量是不可寻址的，当你对数组字面量进行切片操作，其实就是寻找内部元素的地址，下面这段代码会报错

```go
func main() {
    fmt.Println([2]int{2,4,6}[:1])
}
```


