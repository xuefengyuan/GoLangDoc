[TOC]

## 三、原理篇

### 1、局部变量分配在栈上还是堆上？

#### 什么是堆内存和栈内存？

根据内存管理（分配和回收）方式的不同，可以将内存分为**堆内存**和**栈内存**。

他们有什么区别呢？

**堆内存：**由内存分配器和垃圾收集器负责回收。

**栈内存：**由编译器自动进行分配和释放。

一个程序运行过程中，也许会有多个栈内存，但肯定只会有一个堆内存。

每一个栈内存都是由线程或者协程独立占有，因此栈中分配内存不需要加锁，并且栈内存在函数结束后自动回收，性能相对堆内存要高。

而堆内存呢？由于多个线程或者协程都有可能同时从堆中申请内存，因此在堆中申请内存需要加锁，避免造成冲突。堆内存在函数结束后，需要GC（垃圾回收）的介入参与，如果有大量的GC操作，将会使程序性能下降得厉害。

#### 局部变量是从哪里分配的？

在函数里声明定义的变量，我们称之为局部变量。

一般来说，局部变量的作用域仅在该函数中，当函数返回后，所有的局部变量所占用的内存空间都将被回收，对于这类变量，都是从栈上分配内存空间的。

有一种局部变量，比较特殊。

这种局部变量，虽然在函数里声明定义，但是在函数外还会持续的使用。

对于这类局部变量，显然我们是不希望函数退出后就将其销毁的。

那怎么办呢？可以从堆区分配内存空间给这类局部变量。

这个Go的编译器会自行判断做优化。

### 2、为什么常量，字符串和字典不可寻址？

#### 常量

首先要明白一件事，什么叫不可寻址？它指的是，不能通过`&`来获取内存地址的行为。

以常量为例

```go
const VERSION = "V1.0"

func main() {
    fmt.Println(&VERSION)
}
```

编译器会直接报异常，无法取得VERSION的地址。因为它是常量。

如果常量可以寻址的话，我们就可以通过指针修改常量的值，这就破坏了常量的定义。

#### 字典

那么字典元素呢？为什么它不可以寻址？

```go
func main() {
    p := map[string]string{
        "name": "darry",
    }
    fmt.Println(&p["name"])
}
```

它比较特殊，可以从两个方向来推导，假设字典元素是可寻址的，会出现什么问题呢？

字典的使用无非两种情况

1. 如果字典的元素不存在，则返回零值，而零值是不可变对象，这种情况要可寻址就有问题了。
2. 如果字典的元素存在，考虑到Go中map实现中元素的地址是变化的，前一秒key1对应的value1，下一秒可能就对应的value2了，你取地址，不一定能对应更改到map中key1的值。

基于这两点，Map中的元素不可寻址，是合理的。

#### 字符串中的字节或者字符

字符串是不可变的，你想要修改其中某个字符，是做不到的。

```go
func main() {
    name := "darry"
    name[1] = 'B'
}
```

因此字符串的字节或者字符不可寻址

注意区分下面这种写法

`name = "golang"`只是将name指向了一个新的内存地址，这个新的内存地址存的值是`golang`，实际上你并没有改变原字符串`darry`的内存地址里存储的值。

```go
func main() {
    name := "darry"
    name = "Golang"
    fmt.Println(name)
}
```

### 3、为什么Slice元素是可寻址的？

因为Slice底层结构其实是一个匿名数组，既然数组的元素是可寻址的，那么切片的元素也是可寻址的。

```go
type slice struct {
    arry unsafe.Pointer
    len int
    cap int
}
```

### 4、Go中的默认栈大小是多少？最大值是多少？

Go语言中使用用户态线程goroutine作为执行上下文，它的额外开销和默认栈大小都比线程小很多，然而goroutine的栈空间和栈结构也在早期几个版本中发生过改变

- v1.0-v1.1 最小栈内存空间为4kb
- v1.2 最小栈内存提升到了8kb
- v1.3 使用连续栈替换 之前版本的分段栈
- v1.4 最小栈内存降低到了2kb

goroutine的初始栈内存在最初的几个版本中多次修改，从4kb提升到8kb是临时解决方案，其目的是为了减轻分段栈的栈热分裂问题对程序造成的性能影响。

在v1.3版本引入连续栈，在v1.4版本后goroutine的初始栈大小降低到了2kb，减少了goroutine占用的内存空间。

这个栈比x86_64架构下线程的默认栈2M要小很多，是轻量级的用户态线程。

- 默认初始大小是2kb
- 最大不能超过1GB

在GO的源码中`runtime/stack.go`中可以找到。

### 5、Go中的分段栈和连续栈的区别？

#### 分段栈

在Go 1.3版本之前，使用的栈结构是分段栈，随着`goroutine`调用函数层级深入或者局部变量需要的越来越多时，运行时会调用`runtime.morestack`和`runtime.newstack`创建一个新的栈空间，这些栈空间不是连接的，但是当前的`goroutine`的多个栈空间会以双向链表的形式串联起来，运行时会通过指针找到连续的栈片段。

分段栈虽然能够按需为当前`goroutine`分配内存并且及时减少内存的占用，但是它也存在一个比较大的问题。

如果当前的`goroutine`的栈几乎充满，那么任意的函数调用都会触发栈的扩容，当函数返回后又会触发栈的缩容，如果在一个循环中调用函数，栈的分配和释放就会造成巨大的额外开销，这被称为热分裂问题（Hot split）

为解决这个问题，Go在1.2版本的时候将栈初始化内存大小从4kb增加到了8kb，后来采用连续栈后，又把栈初始化大小减小到了2kb。

#### 连线栈

连续栈可以解决分段栈中存在的两个问题，其核心原理就是每当程序的栈空间不足时，初始化一片比旧栈大两位的新栈，并将原栈中的所有值都迁移到新的栈中，新的局部变量或者函数调用就有了充足的内存空间，使用连续栈机制时，栈空间不足导致的扩容会经历以下几个步骤：

1. 调用`runtime.newstack`在内存空间中分配更大的栈内存空间。
2. 使用`runtime.copystack`将旧栈中的所有内容复制到新的栈中。
3. 将指向旧栈对应变量的指针重新指向新栈。
4. 调用`runtime.statckfree`销毁并回收旧栈的内存空间。

`copystack`会把旧栈里的所有内容拷贝到新栈里，然后调整所有指向旧栈变量的指针指向到新栈。

下面这个示例验证下，栈扩容后，同一个变量的内存地址会发生变化。

```go
func main() {
    var x [10]int
    println(&x)
    a(x)
    println(&x)
}

//go:noinline
func a(x [10]int) {
    println(`func a`)
    var y [100]int
    b(y)
}

//go:noinline
func b(x [100]int) {
    println(`func b`)
    var y [1000]int
    c(y)
}

//go:noinline
func c(x [1000]int) {
    println(`func c`)
}
```

输出结果里面`x`的内存地址

```shell
0xc000047f10
...
...
0xc00015df10
```

### 6、内存对齐、内存布局是怎么回事？

**字长（word size）**

字长，指的是CPU一次可访问数据的最大长度

- 对于32位的CPU来说：word size为`2^32`，即 4 byte
- 对于64位的CPU来说：word size为`2^64`，即 8 byte

#### 两种内存布局

##### 第一种：按顺序

代码：

```go
type Foo struct {
    A int8 // 1
    B int8 // 1
    C int8 // 1
}

type Bar struct {
    x int32 // 4
    y *Foo // 8
    z bool // 1
}
```

Bar对象会占用多少的内存？正常下意识的回答是13

回答13是因为你觉得该结构体的内存分配是下面这样按顺序分配的。

按前面所说的 word size为8字节来计算，使用这种分配方式，当你访问bar.y的时候，CPU需要访问两次内存。

![](http://image.iswbm.com/20210925153036.png)

memory layout of Bar1

##### 第二种：按字长

如果使用下面这种方式 ，当你再访问bar.y的时候，CPU只需要访问一次内存

![](http://image.iswbm.com/20210925153041.png)

memory layout of Bar1

因此真正的答案是24，这是一种典型的用空间换时间的方法 - **内存对齐**

```go
func main() {
    var bar Bar
    fmt.Println(unsafe.Sizeof(bar)) 24
}
```

#### 合理定义结构体

上面可以发现，我们定义的结构体虽然不大，只占用了24个byte，但实际有用的只有13个byte，内存使用庇只有50%左右，有优化的空间。

如果将第三个属性挪`y`的前面

![](http://image.iswbm.com/20210925154455.png)

那就可以省下来1个byte了

```go
func main() {
    var bar Bar
    fmt.Println(unsafe.Sizeof(bar))  // 16
}
```

##### y 为什么占用8字节？

看完了上面介绍，有一个疑问点，Foo结构体实际占用了3个byte，为什么Bar.y却要占用8个byte

```go
type Foo struct {
    A int8 // 1
    B int8 // 1
    C int8 // 1
}

type Bar struct {
    x int32 // 4
    y *Foo // 8
    z bool // 1
}
```

因为`bar.y`表示的是一个指针，而指针的对齐系数是8

```go
func main() {
    var bar Bar
    fmt.Println(unsafe.Alignof(bar.y)) // 8
}
```

如果将y改成普通对象

```go
type Foo struct {
    A int8 // 1
    B int8 // 1
    C int8 // 1
}

type Bar struct {
    x int32 // 4
    y Foo  // 3
    z bool  // 1
}
```

这样，bar的对象就只占用1个byte了

```go
func main() {
    var bar Bar
    fmt.Println(unsafe.Sizeof(bar)) // 8
}
```

### 7、Go里是怎么比较相等与否？

#### 7.1两个interface比较

interface的内部实现包含了两个字段，一个是byte，一个是data

![](http://image.iswbm.com/20200610235106.png)

因此两个interface比较，就与这两个字段有关系。

只有下面两种情况，两个interface才会相等

##### 第一种情况

**type和data都相等**

下面示例中，p1 和 p2 的type都是Profile，data都是`{"darry"}`，因此 p1 与 p2 相等

而p3和p4虽然类型都是`*profile`，但由于data存储的是结构体的地址，而两个地址不相同，因此p3和p4不相等

```go
type Profile struct {
    Name string
}

type ProfileInt interface {}

func main() {
    var p1, p2 ProfileInt = Profile{"darry"}, Profile{"darry"}

    var p3, p4 ProfileInt = &Profile{"ring"}, &Profile{"ring"}

    fmt.Printf("p1 --> type: %T, data: %v \n", p1, p1)
    fmt.Printf("p2 --> type: %T, data: %v \n", p2, p2)
    fmt.Println(p1 == p2) // true

    fmt.Printf("p3 --> type: %T, data: %p \n", p3, p3)
    fmt.Printf("p4 --> type: %T, data: %p \n", p4, p4)
    fmt.Println(p3 == p4) // false
}
```

运行结果：

```shell
p1 --> type: config.Profile, data: {darry} 
p2 --> type: config.Profile, data: {darry} 
true
p3 --> type: *config.Profile, data: 0xc000043240 
p4 --> type: *config.Profile, data: 0xc000043250 
false
```

##### 第二种情况

特殊情况，两个interface都是nil

当一个interface的type和data都是处于unset状态的时候，那么该interface的值就为nil

```go
type ProfileInt interface{}

func main() {
    var p1,p2 ProfileInt
    fmt.Println(p1 == p2)
}
```

#### 7.2 interface与百interface比较

当interface与非interface比较时，会将非interface转换成interface，然后再按**照两个interface比较**的规则进行比较

正常示例：

```go
func main() {
    var a string = "darry"
    var b interface = "darry"
    fmt.Println(a == b)
}
```

特殊示例：下面这个例子，经过转换后，看到他们是不相等的

```go
func main() {
    var  a *string = nil
    var b interface{} = a
    
    fmt.Prinln( b == nil)
}
```

当nil转换为interface后是`(type = nil, data = nil)`，这与b `(type = *string, data = nil)`虽然data是一样的，但type不相等，所以不一样。

### 8、所有的T类型都有*T类型吗？

`*T`类型的对象指的是类型是T的对象指针，只有当T类型的对象，是可以寻址的情况，才可以取到其指针。

如string、map的元素、常量、包级别的函数，都是不可寻址的，它们都没有对应的`*T`类型

如下常量的例子：ide编译器直接报异常

```go
type T string
func (T *T) say() {
    fmt.Println("hello")
}

func main() {
    const NAME T = "darry"
    NAME.say()
}
```

### 9、数组对比切片有哪些优势？

#### 9.1、编译检查越界

由于数组在声明后，长度是固定的，因此在编译的时候编译器可以检查在索引取值的时候，是否有下标越界

```go
func main() {
    array := [2]int{}
    array[2] = 2
}
```

而切片的长度只有在运行时长知道，编译器无法检查。

#### 9.2、长度是类型的一部分

在声明一个数组类型时，需要指明两点：元素类型和元素个数。

```go
var arr [2]int
```

长度是数组类型的一部分，两个元素类型相同，但可包含的元素个数不同的数组，属于两个类型。

```go
func main() {
    var array1 [2]int
    var array2 [2]int
    var array3 [3]int
    fmt.Println(reflect.TypeOf(array1) == reflect.TypeOf(array2)) // true
    fmt.Println(reflect.TypeOf(array1) == reflect.TypeOf(array3)) // false
}
```

基于这个特点，可以用它来达到一些合法性校验的目的，例如IPv4的地址可以声明为[4]byte，符合该类型的数组就是合法的ip。

#### 9.3、数组可以比较

类型相同的两个数组可以进行比较

```go
func mian() {
    array1 := [2]int{1,2}
    array2 := [2]int{1,2}
    array3 := [2]int{2,1}
    fmt.Println(array1 == array2) // true
    fmt.Println(array1 == array3) // false
}
```

类型不同（长度不同）的数组和切片均不行。可比较这个特性，决定了数组可以当map的key使用

```go
func main() {
    array := [2]int{1,2}
    dict := make(map[[2]int]string)
    dict[array] = "word"
    fmt.Println(dict)
}
```

### 10、GMP偷取G为什么不需要加锁？

P从全局队列取G的时候，由于可能有多个P同时到G的情况，因此需要加锁，这很容易理解。然后P从本地队列取G的时候，正常情况下，只有自己G，不用加锁也没关系。但问题在于当其他的P处于自旋状态的时候，就有可能来自己这边偷G了。

如此看来，P的本地队列也有并发竞争问题，为什么网上的文章都说从P本地队列里取G的时候，也不用加锁呢？

P从本地队列取G的这个操作，是一个CAS操作，这具有原子性，由于硬件是直接支持的，不需要并发的竞争关系。

而我们常见的加锁操作来避免并发竞争的问题，是从操作系统层面来实现的。

因止GMP中偷取G的过程也是不需要加锁的。

CAS的原子操作虽然可以让程序变得简单，但也要付出一定的代码，使用CAS有两个小问题：

1. 使用CAS为保证执行成功，程序需要for循环不断尝试，直到成功才返回，因止如果CAS长时间不成功，就会阻塞其它硬件对CPU的访问，开销比较大
2. 每次使用CAS原子操作时，一般只能对一个共享变量做操作，要对多个共享变量做操作，循环CAS可能就不好做，不过应该可以通过多个变量放在一个对象里来进行CAS操作

下面示例是网上的CAS操作代码

```go

var(
	counter int32
	wg sync.WaitGroup
)
func main() {
    threadNum := 5 //1. 五个信号量
    wg.Add(threadNum) //2.开启5个线程
    for i := 0; i < threadNum; i++ {
        go incCounter(i)
    }
    //3.等待子线程结束
    wg.Wait()
    fmt.Println(counter)
}

func incCounter(index int) {
    defer wg.Done()
    spinNum := 0
    for {
        //2.1原子操作
        old := counter
        ok := atomic.CompareAndSwapInt32(&counter, old, old+1)
        if ok {
            break
        } else {
            spinNum++
        }
    }
    fmt.Printf("thread,%d,spinnum,%d\n",index,spinNum)
}
```

