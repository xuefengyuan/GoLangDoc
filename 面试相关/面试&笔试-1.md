[TOC]

# 一、基础篇

### 1、Go中的=和:=有什么区别？

在对一个变量进行赋值前，首先要声明其类型。

```go
// 声明
var age int
// 赋值
age = 18
```

上面两行代码可以使用`:=`来合并成一行代码

```go
age := 18
```

因此它们之间的区别是

- `=` 是赋值
- `:=` 是声明并赋值

一个变量只能声明一次，使用多次`:=`是不允许的，当声明一次后却可以赋值多次，没有限制。

### 2、Go中的指针的意义是什么？

**什么是指针，和指针变量**

普通的变量，存储的是数据，而指针变量，存储的是数据的内存地址。

学习指针，主要有两个运算符。

- `&`：地址运算符，从变量中取得值的内存地址

```go
// 定义普通变量并打印
age := 18
fmt.Pringln(age) // output: 18

prt := &aeg
fmt.Pringln(prt) // output: age的内存地址
```

- `*`：解引用运算符，从内存地址中取得存储的数据

```go
myage := *prt
fmt.Println(myage) // output: 18
```

**指针的意义是什么**

意义一：省内存

> 当你往一个函数传递参数时，若该参数是一个值类型的变量，则在调用函数时，会将原来的变量的值拷贝一遍。
>
> 假想每次传参数都用数组，那么每次数组都要被复制一遍，如果数据大小有100万，在64伴的机器上就需要大约800W字节，即8MB的内存，这样会消耗大量的内存。

意义二：易编码

> 写了一个函数来实现更新某对象里的一些数据，在值类型的变量中，若不使用指针，则函数需要重新返回一个更新过的对象
>
> 使用指针，则可以不用返回对象

### 3、Go多值返回有什么用？

Go语言中函数可以返回多个值，这和其它编程语言有很大的不同。对于有其它编译的编程经验的人来说，最大的障碍不是学习这个特性，而是很难想到去使用这个特性。

利用这个特性，在Go中实现变量的交换，就不需要再使用中间变量(表象上看是这样，但实际上还是会变量的拷贝)了，非常方便

```go
package main

import "fmt"

func swap(a, b int) (int, int) {
    return b, a
}

func main() {
    a := 1
    b := 2
    a, b = swap(a, b)

    fmt.Println(a)
    fmt.Println(b)
}
```

如果返回的值，有不需要的，可以直接使用占位符`_`接收，表示丢弃这个值。

```go
a, _ = swap(a, b)
```

在Go中没有异常机制，当一个函数运行出错的时候，除了返回该功能函数的结果外，还应该返回一个error类型的值。

若该值为nil则表示函数正常运行结束，反之，则函数运行异常。

这是Golang这门语言的设计哲学，因此我们不管在看别人的代码，或者自己写代码都会发现代码中处理都有下面这段代码的身影。

```go
if err != nil {
    // handle error
}
```

### 4、Go有异常类型吗？

在解决这个问题之前，有必要对错误和异常做一个解释。

- **错误**：指的是可能出现问题的地方出现了问题，比如打开一个文件时失败，这种情况下在意料之中的。
- **异常**：指的是不应该出现问题的出现了问题，比如引用了空指针，这种情况在人们的意料之外。

**在Golang里面没有异常类型，只有错误类型 (Error)**

一个函数要想返回错误，通常会使用返回值来表示异常状态，它很像C语言中的错误码，可逐层返回，直到被处理。

```go
f, err := os.Open("test.txt")
if err != nil {
    log.Fatal(err)
}
```

Golang语言中虽然没有异常的概念，但却有更恐怖的panic，由于有了recover，在一定程序上，panic可以类比做异常。

Golang错误和异常 (panic) 是可以相互转换的：

1、**错误转异常**：比如程序逻辑上尝试请求某个URL，最多尝试三次，尝试三次的过程中请求失败是错误，尝试三次后还不成功的话，失败就提升为异常了。

2、**异常转错误**：比如panic触发的异常被recover恢复后，将返回值中的error类型的变量进行赋值，以便上层函数继续走错误处理流程。

### 5、Go中的rune和byte有什么区别？

一个字符串是由若干个字符组合而成的，比如`hello`，就有5个字符组成。

在Golang的字符类型有两种，分别是：

1、byte类型：字节，是unit8的别名类型

2、rune类型：字符，是int32的别名类型

byte和rune，虽然都能表示一个字符，但byte只能表示ACSII码表中的一个字符(ACSII码表总共有256个字符)，数量远不如rune多。

rune表示的是Unicode字符中的任一字符，而Unicode是一个可以表示世界范围内的绝大部分字符的编码，这张表里几乎包含了全世界的所有字符，也包括中文。

能表示的字符更多，意味着它占用的空间，也要更大，所占用空间是4个byte的大小。

以下代码来验证下他们占用空间的差异

``` go
var a byte = 'A'
var b unre = 'B'
fmt.Printf("a 占用 %d 个字节数组\n", unsafe.Sizeof(a)) // 1 个字节
fmt.Printf("b 占用 %d 个字节数组 \n", unsafe.Sizeof(b)) // 4个字节
```

### 6、Go语言中的深拷贝和浅拷贝？

**什么是拷贝？**

当你把a变量的赋值给b变量时，其实就是把a变量拷贝给b变量

```go
a := "hello"
b := a
```

这只是拷贝最简单的一种形式，而有些形式却表现得非常的隐蔽。比如：

- 你往一个函数中传参
- 你向通道中传入对象

这些其实是在Go编译器中都会进行拷贝的动作

**什么是深浅拷贝？**

知道了什么是拷贝，我们再往深点开挖，聊聊深浅拷贝。

咱们先了解下数据结构的两种类型：

- **值类型**：String、Array、Int、Struct、Float、Bool
- **引用类型**：Slice、Map

这两种不同类型在拷贝的时候，在拷贝的时候效果是完全不一样的，这对于很多新手可能是一个坑。

对于值类型来说，你的每一次拷贝，Go都会新申请一块内存空间，来存储它的值，改变其中一个变量并不会影响另外一个变量

```go
func tArry() {

    aArr := [3]int{1, 2, 3}
    fmt.Println(aArr)
    bArr := aArr
    aArr[0] = 5
    fmt.Println("将 aArr 拷贝给 bArr 后，并修改 aArr[0] = 5")
    fmt.Printf("打印 aArr: %v \n", aArr)
    fmt.Printf("打印 bArr: %v \n", bArr)
}
// output
[1 2 3]
将 aArr 拷贝给 bArr 后，并修改 aArr[0] = 88
打印 aArr: [5 2 3] 
打印 bArr: [1 2 3] 
```

从输出结果来看，aArr和bArr相互独立，互不干扰

对于引用类型来说，你的每一次拷贝，Go不会申请新的内存空间，而是使用它的指针，两个变量名其实都指向同一个内存空间，改变其中一个变量，会直接影响另一个变量。

```go
func tSlice() {

    aSlice := []int{1, 2, 3}
    fmt.Println(aSlice)
    bSlice := aSlice
    aSlice[0] = 9
    fmt.Println("将 aSlice 拷贝给 bSlice 后，并修改 aSlice[0] = 9")
    fmt.Printf("打印 aSlice: %v \n", aSlice)
    fmt.Printf("打印 bSlice: %v \n", bSlice)
}

// output
[1 2 3]
将 aSlice 拷贝给 bSlice 后，并修改 aSlice[0] = 9
打印 aSlice: [9 2 3] 
打印 aSlice: [9 2 3] 
```

从上面输出结果看，aSlice的更新直接影响到了bSlice的值

### 7、什么叫字面量和组合字面量？

#### 7.1、什么是字面量？

在Golang的内置基本类型有：

- 布尔类型：bool
- 11个内因的整数数字类型：int8、uin8、int16、uint16、int32、uint32、int64、uint64、int、uint、uintptr
- 浮点数类型：float32、float64
- 复数类型：complex64、complex128
- 字符串类型：string

<font color="red">**这些基本类型的值的文本，就是基本类型字面量。**</font>

如下面这两个字符串，都是字符串字面量，没有用变量名或者常量名来指向这两个字面量，因此也称之为**未命名常量**

```go
"hello, iswbm"

`hello,
iswbm`
```

#### 7.2、同值不同字面量

值的字面量(literal)是代码中值的文字表示，一个值可能存在多种字面量表示。

举个例子，十进制的数值15，可以由三种字面量表示

```go
// 16进制
0xF

// 8进制
017

// 2进制
0b1111
```

通过代码比较，可以看出他们是相等的。

```go
func main() {
    fmt.Println(15 == 0xF)     // true
    fmt.Println(15 == 017)     // true
    fmt.Println(15 == 0b1111)  // true
}
```

#### 7.3、字面量和变量有什么区别？

下面是一段很正常的代码

```go
func foo() string {
    return "hello"
}

func main() {
    bar := foo()
    fmt.Println(&bar)
}
```

换成下面这样

```go
func foo() string {
    return "hello"
}

func main() {
    fmt.Println(&foo())
}
```

在Go 1.7版本中编译器直接报错，如果不是智能的ide编写的代码会在运行过程中报错。

为什么先用变量名接收下再取地址就不会报错，而直接使用在函数返回的值上取地址就不行呢？

这是因为如果不使用一个变量名接收下，函数返回的是一个字符串的文本值，也就是字符串字面量，而这种基本类型的字面量是不可寻地的。

想要使用`&`进行寻址，就必需要用变量名接收下。

#### 7.4、什么是组合字面量？

组合字面量是为结构体、数组、切片、和map构造值，并且每次都会创建新值，它们由字面量的类型后紧跟大括号及元素列表，每个元素面前可以选择性的带一个相关key

**什么意思呢？所谓的组合字面量其实就是把对象的定义和初始化放在一起。**

下面我们来看看结构体、数组、切片和map各自的常规方式和组合字面量方式

**结构体的定义和初始化**

一个struct结构体的常规和定义和初始化是怎么样的

**常规方式**

常规方式这样定义逐一字段赋值，比较繁琐。

```go
type Profile struct {
    Name string
    Age int
    Gender string
}

func main() {
    // 声明对象
    var xm Profile
    
    // 属性赋值
    xm.Name = "iswbm"
    xm.Age = 18
    xm.Gender = "male"
}
```

**组合字面量方式**

```go
type Profile struct {
    Name string
    Age int
    Gender string
}
func main() {
    // 声明+属性赋值
    xm := Profile {
        name: "iswbm",
        Age: 19,
        Gender: "male",
    }
}
```

**数组的定义和初始化**

**常规方式**

下面代码中，我们定义一个指定元素大小的字符串数组，然后一个一个的给元素赋值，即数组变量定义和赋值是分开的。

```go
var planets [4]string

planets[0] = "Mercury"
planets[1] = "Venus"
planets[2] = "Earth"
```

**组合字面量方式**

下面代码是将变量定义和初始化合并了在一起

```go
balls := [4]string {"basketball", "football", "volleyball", "tennis"}
```

**slice的定义和初始化**

**常规方式**

```go
// 第一种
var s []string // 定义切片变量，默认零值nil
s = append(s, "hat", "shirt") // 往s中添加元素，len(s):2,cap(2):2

// 第二种
s := make([]string, 0, 10) // 定义s, s的默认值不为nil

```

**组合字面量方式**

由上面的常规方式或以知道，首先都是要先定义切片，然后再往切片中添加元素。下面看下组合字面方式

```go
s := []string {"hat", "shirt"} // 定义和初始化一步完成，自动计算切片的容量和长度

var s = []string {"hat", "shirt"}
```

**map和定义和初始化**

**常规方式**

```go
// 通过make函数初始化
m := make{map[string]int, 10}
m["english"] = 99
m["math"] = 98
```

**组合字面量方式**

```go
m := map[string]int {
    "english":90,
    "math":80,
}

// 组合字面量初始化多维map
m2 := map[string]map[int]string {
    "english":{
        11:"math",
    },
}
```

使用组合字面量会比常规方式简单不少。

#### 7.5、字面量的寻地问题

字面量，说白了就是未命名的常量，跟常量一样，是不可以寻址的。

以数组字面量为例进行说明

```go
func foo() [3]int {
    return [3]int{1, 2, 3}
}

func main() {
    fmt.Println(&foo())
}

```

### 8、对象选择器自动解引用怎么用？

从一个结构体实例对象中获取属性字段的值，通常都是使用`.`这个操作符，该操作符叫作选择器。

当对象是结构体指针时，你想要获取属性字段时，常规理解是这样做

```go
type Profile struct {
    Name string
}

func main() {
    p1 := &Profile{"iswbm"}
    fmt.Println((*p1).Name)
}
```

更简洁的做法，可以直接省去`*`的取值操作，选择器`.`会直接解引用

```go
type Profile struct {
    Name string
}

func main() {
    p1 := &Profile{"iswbm"}
    fmt.Println(p1.Name)
}
```

```go
type Person struct {
    Name string
}

type (p *Person) Say() {
    fmt.Println((*p).Name)
}

// 可以使用下面这种方式
type (p *Person) Say1() {
    fmt.Println(p.Name)
}
```











































